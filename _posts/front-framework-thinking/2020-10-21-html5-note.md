---
title: "HTML5 新特性"
subtitle: ""
layout: post
author: "libyasdf"
header-style: text
tags:
  - HTML5
  - Canvas
  - SVG
---
# Input

增加了很多属性，但是浏览器支持方面差强人意，明显体现在date那几个属性上。

# canvas

找到 &lt;canvas&gt; 元素:
```
var c=document.getElementById("myCanvas");
```
然后，创建 context 对象：
```
var ctx=c.getContext("2d");
```
getContext("2d") 对象是**内建的 HTML5 对象**，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。

下面的两行代码绘制一个红色的矩形：
```
ctx.fillStyle="#FF0000";
ctx.fillRect(0,0,150,75);
```
# SVG 使用 XML 格式定义图形
![canvas对比SVG](/img/html/canvas-svg.png)  

# SVG 与 Canvas两者间的区别

SVG 是一种使用 XML 描述 2D 图形的语言。

Canvas 通过 JavaScript 来绘制 2D 图形。

SVG 基于 XML，这意味着 SVG DOM 中的**每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器**。

在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。

Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。**如果其位置发生变化，那么整个场景也需要重新绘制**，包括任何或许已被图形覆盖的对象。

# MathML

>数学标记语言，是一种基于XML（标准通用标记语言的子集）的标准，用来在互联网上书写数学符号和公式的置标语言。  

对浏览器有要求，部分样式没有出来。
```
<mn>上角
<mi>下角
矩阵等
```

# Drag 和 Drop

* 设置元素为可拖放
首先，为了使元素可拖动，把 draggable 属性设置为 true ：
```
<img draggable="true">
```

* 拖动什么 - ondragstart 和 setData()  

ondragstart 属性调用了一个函数，drag(event)，它规定了被拖动的数据。

dataTransfer.setData() 方法设置被拖数据的数据类型和值：
```
function drag(ev)
{
    ev.dataTransfer.setData("Text",ev.target.id);
}
```
Text 是一个 DOMString 表示要添加到 drag object 的拖动数据的类型。值是可拖动元素的 id ("drag1")

* 放到何处 - ondragover  

ondragover 事件规定在何处放置被拖动的数据。

默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。

这要通过调用 ondragover 事件的 event.preventDefault() 方法：
```
event.preventDefault()
```

* 进行放置 - ondrop  

当放置被拖数据时，会发生 drop 事件。

在上面的例子中，ondrop 属性调用了一个函数，drop(event)：
```
function drop(ev)
{
    ev.preventDefault();
    var data=ev.dataTransfer.getData("Text");
    ev.target.appendChild(document.getElementById(data));
}
```
代码解释：

调用 preventDefault() 来避免浏览器对数据的默认处理（**drop 事件的默认行为是以链接形式打开**）  
通过 dataTransfer.getData("Text") 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。  
被拖数据是被拖元素的 id ("drag1")  
把被拖元素追加到放置元素（目标元素）中

[拖拽代码](https://www.runoob.com/html/html5-draganddrop.html)  

# Geolocation

用于获得用户的地理位置

```
var x=document.getElementById("demo");
function getLocation() {
	if (navigator.geolocation)
	{
		navigator.geolocation.getCurrentPosition(showPosition,showError);
	}
	else
	{
		x.innerHTML="该浏览器不支持获取地理位置。";
	}
}

function showPosition(position) {
	x.innerHTML="纬度: " + position.coords.latitude + 
	"<br>经度: " + position.coords.longitude;	
}

function showError(error)
{
	switch(error.code) 
	{
		case error.PERMISSION_DENIED:
			x.innerHTML="用户拒绝对获取地理位置的请求。"
			break;
		case error.POSITION_UNAVAILABLE:
			x.innerHTML="位置信息是不可用的。"
			break;
		case error.TIMEOUT:
			x.innerHTML="请求用户地理位置超时。"
			break;
		case error.UNKNOWN_ERROR:
			x.innerHTML="未知错误。"
			break;
	}
}
```
**如果 getCurrentPosition() 运行成功，则向参数showPosition中规定的函数返回一个 coordinates 对象**

_速度与浏览器相关_：Chrome不理想  

# video 与 audio
**手机端不理想？**
```
<video width="320" height="240" controls>
  <source src="movie.mp4" type="video/mp4">
  <source src="movie.ogg" type="video/ogg">
  您的浏览器不支持 HTML5 video 标签。
</video>
```
**&lt;video&gt; 元素支持多个 &lt;source&gt; 元素. &lt;source&gt; 元素可以链接不同的视频文件。浏览器将使用第一个可识别的格式：**
DOM上有方法
```
var myVideo=document.getElementById("video1"); 

function playPause()
{ 
	if (myVideo.paused) 
	  myVideo.play(); 
	else 
	  myVideo.pause(); 
} 
//	myVideo.width=560; 

```

```
<audio controls>
  <source src="horse.ogg" type="audio/ogg">
  <source src="horse.mp3" type="audio/mpeg">
您的浏览器不支持 audio 元素。
</audio>
```

# 表单元素

## &lt;datalist&gt;
输入一个字母过滤出对应项：
```
<form action="demo-form.php" method="get">
<input list="browsers" name="browser">
<datalist id="browsers">
  <option value="Internet Explorer">
  <option value="Firefox">
  <option value="Chrome">
  <option value="Opera">
  <option value="Safari">
</datalist>
<input type="submit">
</form>
```
## &lt;keygen&gt;
**使用node看一下服务器得到了什么??**
当提交表单时，会生成两个键，一个是私钥，一个公钥。

私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）  
```
<form action="demo_keygen.php" method="get">
  用户名: <input type="text" name="usr_name">
  加密: <keygen name="security">
  <input type="submit">
</form>
```
## &lt;output&gt;
用于不同类型的输出，比如计算或脚本输出
```
<form oninput="x.value=parseInt(a.value)+parseInt(b.value)">0
<input type="range" id="a" value="50">100
+<input type="number" id="b" value="50">
=<output name="x" for="a b"></output>
</form>
```

```
<form oninput="result.value=parseInt(a.value)+parseInt(b.value)">
    <input type="range" name="b" value="50" /> +
    <input type="number" name="a" value="10" /> =
    <output name="result"></output>
</form>
```

# 表单属性

## &lt;form> / &lt;input> autocomplete 属性
**提交之后的记忆，回填**
```
<form action="demo-form.php" autocomplete="on">
  First name:<input type="text" name="fname"><br>
  Last name: <input type="text" name="lname"><br>
  E-mail: <input type="email" name="email" autocomplete="off"><br>
  <input type="submit">
</form>
```

## &lt;form> novalidate 属性
>novalidate 属性是一个 boolean(布尔) 属性.

novalidate 属性规定在提交表单时不应该验证 form 或 input 域。

## &lt;input> autofocus

自动获取焦点

## &lt;input> form 属性

填上form的id，这个input就成了那个表单的一部分

## &lt;input> formaction 属性
The formaction 属性用于描述表单提交的URL地址.

The formaction 属性会覆盖&lt;form> 元素中的action属性.
```
<form action="demo-form.php">
  First name: <input type="text" name="fname"><br>
  Last name: <input type="text" name="lname"><br>
  <input type="submit" value="提交"><br>
  <input type="submit" formaction="demo-admin.php"
  value="提交">
</form>
```
**注意: The formaction 属性用于 type="submit" 和 type="image".**

## &lt;input> formenctype 属性
```
formenctype="multipart/form-data"
```
formenctype 属性描述了表单提交到服务器的数据编码 (只对form表单中 method="post" 表单)

formenctype 属性覆盖 form 元素的 enctype 属性。

**主要: 该属性与 type="submit" 和 type="image" 配合使用。**

## &lt;input> formmethod 属性
```
formmethod="post" 
```

## &lt;input> formnovalidate 属性
```
formnovalidate="formnovalidate"
```

## &lt;input> formtarget 属性
**提交到一个新的页面上**但是在Chrome上，都开了新页面？
```
formtarget="_blank"
```

## &lt;input> height 和 width 属性

## &lt;input> list 属性
```
<form action="demo-form.php" method="get">
<input list="browsers" name="browser">
<datalist id="browsers">
  <option value="Internet Explorer">
```
## &lt;input> min 和 max 属性

## &lt;input> multiple
>multiple 属性是一个 boolean 属性.

multiple 属性规定input 元素中可选择多个值。

## &lt;input> pattern 属性
pattern 属性描述了一个正则表达式用于验证 &lt;input> 元素的值。

注意:pattern 属性适用于以下类型的 &lt;input> 标签: text, search, url, tel, email, 和 password.

## 其它
```
数字间隔
<input type="number" name="points" step="3">

必须填写
<input type="text" name="usrname" required>

描述输入域所期待的值
<input type="text" name="fname" placeholder="First name">
```

# 语义元素

清楚的描述其意义给浏览器和开发者。
```
都是块元素(除了<figcaption>)
<header>
<nav>
<section>
<article>
<aside>
<figcaption>
<figure>
<footer>
```
##  &lt;figure> 和 &lt;figcaption> 元素

&lt;figure>标签规定独立的流内容（图像、图表、照片、代码等等）。

&lt;figure> 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。

&lt;figcaption> 标签定义 &lt;figure> 元素的标题.

&lt;figcaption>元素应该被置于 "figure" 元素的第一个或最后一个子元素的位置。

```
<figure>
  <img loading="lazy" src="img_pulpit.jpg" alt="The Pulpit Rock" width="304" height="228">
  <figcaption>Fig1. - The Pulpit Pock, Norway.</figcaption>
</figure>
```

# Web 存储

>使用HTML5可以在本地存储用户的浏览数据。  

>早些时候,本地存储使用的是 cookie。但是Web 存储需要更加的安全与快速. 这些数据不会被保存在服务器上，但是这些数据只用于用户请求网站数据上.它也可以存储大量的数据，而不影响网站的性能.

>数据以 键/值 对存在, web网页的数据只允许该网页访问使用。

## localStorage 和 sessionStorage 

* localStorage - 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。
* sessionStorage - 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。

## localStorage 对象
```
if(typeof(Storage)!=="undefined")
{
  localStorage.sitename="liby";
  document.getElementById("result").innerHTML="网站名：" + localStorage.sitename;
}
else
{
  document.getElementById("result").innerHTML="对不起，您的浏览器不支持 web 存储。";
}
```
移除：
```
localStorage.removeItem("sitename");
```
保存数据：localStorage.setItem(key,value);  
读取数据：localStorage.getItem(key);  
删除单个数据：localStorage.removeItem(key);  
删除所有数据：localStorage.clear();  
得到某个索引的key：localStorage.key(index);
**localStorage.key(index)不准**

## sessionStorage 对象
>关闭浏览器窗口后，数据会被删除。

## 作用域
![作用域](/img/html/storagescope.png)
这里的作用域指的是：如何隔离开不同页面之间的localStorage（总不能在百度的页面上能读到腾讯的localStorage吧，哈哈哈）。

localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。

sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。